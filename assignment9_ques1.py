# -*- coding: utf-8 -*-
"""Assignment9:ques1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PnLG3fO6wuL2h740nlxVg2rVd6Z_F1ku
"""



"""# 9th July --- Friday---- Assignment 9---- 
question1.

Q-1> Use the Faker (Links to an external site.)library to get 10000 random profiles. Using namedtuple, calculate the largest blood type, mean-current_location, oldest_person_age, and average age (add proper doc-strings).

Q-2>> Do the same thing above using a dictionary. Prove that namedtuple is faster.
"""

!pip install Faker


from collections import namedtuple
from faker import Faker

Faker.seed(0)
fake = Faker()

fp={}                            # declared a dic
profile_count=10_000

for i in range(profile_count):
  fp[i]=fake.profile()           # output dict

print(type(fp))

# step1 -  create a namedtuple header/ key/ name
# step2 -  write algo to take all values from dict to namedtuple
# step3 -  merge all namedtuples into 1 tuple
# step4 -  start calculation : alculate the largest blood type, mean-current_location, oldest_person_age, and average age

# step 1
fake_profilex = namedtuple('fake_profiley', sorted(fp[0].keys()))
print(fake_profilex._fields)
# print(type(fake_profilex))     <class 'type'>        tuple
# print (fp[0].keys())
print(len(fake_profilex._fields))

# step 2 write algo to take all values from dict to namedtuple
 
fake_profile_tuple={}    #-------> defined/initialized as dict

for i in range (profile_count):
  fake_profile_tuple[i] = fake_profilex(**fp[i])
  print(fake_profile_tuple[i])                    # tuple

# type(fake_profile_tuple) ----> dict
type(fake_profile_tuple[0]) #----> tuple

# # step3 -  merge all namedtuples and start calculation: largest blood type, mean-current_location, oldest_person_age, and average age
            # trying to add 10_000 tuples in a single tuple by iteration
            # fake_profile_tuple[i]   current tuple

#------------------------------  WORKS !!! WOOHOOO------------
tuple_merged= ()

for i in range(profile_count):
  tuple_merged= tuple_merged+ (fake_profile_tuple[i],)
print(type(tuple_merged))                             # TUPLE
print(len(tuple_merged))                              # 5

# step4 -  start calculation : calculate the largest blood type, mean-current_location, oldest_person_age, and average age

          # calculation1: oldest person age

'''-------------------------  WORKS !!!!! :D ----------------------------------------------'''

from time import perf_counter

start= perf_counter()
# birthdates = tuple([t[1] for t in tuple_merged])    # give tuple of bithdates of all profiles 
birthdates = [t[1] for t in tuple_merged]               # give list of bithdates of all profiles ----> faster than tuple
oldest=min( birthdates )
age_oldest= datetime.date.today() - oldest          # type: datetime.timedelta
end=perf_counter()
timetaken= end- start

index_oldest=birthdates.index(oldest)
oldest_person=tuple_merged[index_oldest][7]

print('bithdates',birthdates)
print('oldest', oldest)
print('age_oldest',age_oldest)
print('timetaken',timetaken )
print('oldest person is', oldest_person)

#calculation2: average age calculation

age= [(datetime.date.today()-t[1]) for t in tuple_merged] 
age_total= age[0]
for i in range(profile_count-1):
  age_total+= age[i+1]
age_average= age_total/ len(age)       # type:   datetime.timedelta
print('age_average',age_average)

#calculation3: largest blood type-- METHOD2
def most_frequent(bloodtype):
    return max(set(bloodtype), key = bloodtype.count)
  
print(most_frequent(bloodtype))

#calculation4: mean-current_location

current_location = [t[4] for t in tuple_merged] 
mean_location= sum(t[0] for t in current_location)/profile_count, sum(t[1] for t in current_location)/profile_count
print('mean_location is ', mean_location)